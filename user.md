这篇先介绍以下项目的起因和用户系统说明

## 起因

这个项目是为了总结下 IM 的基础应用，社区目前这方面的内容都比较少或者太简陋（只有一个公共的聊天室这种）。另外就是在业务开发过程中被 PM 搞得很难受，所以想脱离一些特有的业务上的东西，实现一个功能简单五脏俱全的一个应用，也就是微信。选择微信是因为我很熟悉，不用在产品上面思考太多，另外就是试用的人很熟悉，不需要太多的沟通成本。

## 关系

作为一个前端工程师，很多时候是不思考实体关系的。但是，就我的实际体验来看，懂得实体关系可以帮助我们更好的理解业务模型。而对产品和业务理解的提升对我们的帮助是非常大的，可以在需求评审的时候发现很多不符合逻辑的地方，这时候能提出来就会主动避免我们在后续的过程中进行反复开发，同时可以和产品侧的同学形成比较良好的互动（而不是互怼）。

数据库中的实体关系请看下图：

![](https://i.loli.net/2020/05/18/VZNYBMHQeGPhjq9.png)

通过上图可以看到 user 是整个关系图中的核心，下面介绍下各个实体的关系：

1. user 和 user_info 是一对一的关系
2. user 和 role(角色)是多对多的关系
3. role 和 right(权限)是多对多的关系
4. user 和 apply(申请)是多对多的关系，申请都是涉及到两个 user（申请人和被申请人）
5. user 和 group(群组)是多对多的关系
6. user 和 conversation(会话)是多对多的关系
7. group 和 conversation 是一对一的关系
8. conversation 和 message(消息)是 1 对多的关系

### 角色和权限

为了设计一个灵活、通用、方便的权限管理系统，本系统采用 RBAC（基于角色的访问控制）控制，来设计一个通用“用户角色权限”平台。

#### RBAC

RBAC（基于角色的访问控制）是指用户通过角色与权限进行关联。即一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户—角色—权限”的授权模型。在这种模型中，用户与角色之间、角色与权限之间，一般者是多对多的关系。

#### 本系统的角色和权限

本系统有管理员和一般用户这两种角色，给不同的角色分配不同的权限，所以需要针对管理和普通用户的接口路由做一下统一的鉴权（通过中间件的方式）处理，具体方式和方法在后端项目中会详细说明。本系统暂时采用预先定义了角色和权限的方式，后续想要扩展的话可以开放对角色和权限的分别配置功能。

#### 普通用户

注册登录后，可以正常的添加好友和加入群组，可以修改个人基础信息和处理申请

1. 注册登录
2. 编辑个人基础信息
3. 添加好友，申请入群
4. 处理好友申请和入群申请
5. 聊天
6. 群主踢人

#### 管理员

没见过微信的管理端，但是可以想象一下，管理员可以编辑配置用户的权限和群的状态：

1. 用户的登录、发言权限
2. 禁言、解散群

### 会话

思考会话和消息、用户、群组之间的关系花费了不少的精力，最终形成以下的基本关系：

1. 2 个用户参与的聊天属于建立了 Friend 关系（互为好友）
2. 多个用户参与的聊天组成了群组关系
3. Friend 和会话之间的关系是 1 对 1 的关系，可以通过 Friend 找到此 Friend 的会话，也可以通过会话确定 Friend
4. 群组和会话之间的关系是 1 对 1 的关系，可以通过群组找到此群组的会话，也可以通过会话确定群组
5. 消息属于某个会话，可以根据会话查看对应的消息列表

也就是说，用户和会话没有直接的关系，只能通过用户对应的单聊和群聊去获取会话，这样做可以有以下的好处：

1. 无论是单聊还是群聊，连接上的用户只要 join 进对应的会话 room 里面就可以，消息也是在对应的 room 里面发布
2. 无论是单聊还是群聊，消息的保存和查询都比较简单，都是只针对这个会话
3. 获取个人的会话列表也变得很简单，用户的会话列表通过查询用户『所有的 Friend 和群组』->『所有的会话』->『排序会话』，就可以获取

### 聊天

聊天分为单聊和群聊，聊天信息暂时有一般的文字、图片消息

## 即时通讯

### WebSocket

我们知道现在的 http 协议是无状态协议，只能由客户端主动发起请求，然后服务端去响应。那么为了实现服务端向客户端推送信息，就需要前端主动向后端去轮询，这种方式低效且容易出错。

为了解决这种需求， HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，也就是 WebSocket。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。WebSocket 协议在 2008 年诞生，2011 年成为国际标准，目前绝大部分浏览器都已经支持了。

WebSocket 的用法相当简单:

```
var ws = new WebSocket("wss://echo.websocket.org");

ws.onopen = function(evt) {
  console.log("Connection open ...");
  ws.send("Hello WebSockets!");
};

ws.onmessage = function(evt) {
  console.log( "Received Message: " + evt.data);
  ws.close();
};

ws.onclose = function(evt) {
  console.log("Connection closed.");
};
```

有了 WebSocket 协议让我们使服务端主动推送有了先进的武器，那么有没有什么方式可以兼容新旧浏览器呢？答案就是`socket.io`

### `socket.io`

`socket.io`进一步封装了`WebSocket`的接口，而且可以在旧版本浏览器中切换到使用轮询的方式进行通讯（我们使用者是不会感知的），形成了一套统一的接口，大大减轻了开发的负担。主要具有以下优点：

1. 封装出了一套非常易用的接口，前后端统一，使用非常简单
2. 全平台支持（原生和 H5，微信小程序中也有对应的实现）
3. 自适应浏览器，在比较老的浏览器中主动切换使用轮询的方式，不需要我们自己搞轮询

[socket.io 主页](https://socket.io/)

> 最快，最可靠的即时通讯引擎(FEATURING THE FASTEST AND MOST RELIABLE REAL-TIME ENGINE)

## 初始数据

### 管理员

### 一般用户
